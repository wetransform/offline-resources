import java.time.*
import java.time.temporal.*
import eu.esdihumboldt.util.config.*

buildscript {
  repositories {
    // mavenLocal()
    maven {
      url 'https://artifactory.wetransform.to/artifactory/local'
    }
    mavenCentral()
  }
  dependencies {
    // for Config class
    classpath 'eu.esdihumboldt.hale:eu.esdihumboldt.util.config:4.0.0'
    // for XMLSchemaUpdater (depends on https://github.com/halestudio/hale/pull/731)
    classpath 'eu.esdihumboldt.hale:eu.esdihumboldt.hale.common.core:4.0.0'

    classpath 'org.ajoberstar.grgit:grgit-core:4.1.1'
  }
}

plugins {
  id 'de.undercouch.download' version '3.4.3'
}

ext {
  resourcesFolder = file('resources')
  hostsFolder = new File(resourcesFolder, 'hosts')
  jarFolder = new File(buildDir, 'jars')
  now = LocalDate.now()
  grgit = org.ajoberstar.grgit.Grgit.open(dir: projectDir)
}

/*
 * Helper classes and task definitions
 */

class MetadataHelper {
  static final METADATA_DIR_NAME = '.metadata'

  private final Project project
  private final File parentDir
  private final File metadataDir
  MetadataHelper(Project project, File parentDir) {
    this.project = project
    this.parentDir = parentDir
    this.metadataDir = new File(parentDir, METADATA_DIR_NAME)
  }

  def withConfig(Closure configure) {
    def configFile = new File(metadataDir, 'metadata.yml')
    configFile.parentFile.mkdirs()
    def config = configFile.exists() ? ConfigYaml.load(configFile) : new Config()
    // unexpectedly, when accessing config, instead of getAt get is used
    // when accessing config -> thus we interact with the map instead
    def map = config.asMap()
    def result = configure(map)
    result
  }

  def updateConfig(Closure configure) {
    def configFile = new File(metadataDir, 'metadata.yml')
    configFile.parentFile.mkdirs()
    def config = configFile.exists() ? ConfigYaml.load(configFile) : new Config()
    // unexpectedly, when accessing config, instead of getAt get is used
    // when accessing config -> thus we interact with the map instead
    def map = config.asMap()
    def result = configure(map)
    ConfigYaml.save(config, configFile)
    result
  }

  private boolean changesInFolder() {
    File checkForDir = parentDir
    File repoRoot = project.projectDir

    def relativePath = repoRoot.relativePath(checkForDir)
    //XXX do we need to replace \ with / for Windows?

    def status = project.ext.grgit.status()

    // check for any changes and conflicts
    return [
      status.conflicts,
      status.staged.added,
      status.staged.modified,
      status.staged.removed,
      status.unstaged.added,
      status.unstaged.modified,
      status.unstaged.removed
    ].any { setOfPaths ->
      def example = setOfPaths.find { it.startsWith(relativePath) && !it.startsWith(relativePath + '/.metadata') }
      if (example) {
        println "Changes detected for path $relativePath (at least $example changed)"
        true
      }
      else {
        false
      }
    }
  }

  void setVersionIfChanged() {
    // only set version if there are changes to parentDir
    if (!changesInFolder()) {
      return
    }

    int year = project.ext.now.getYear();
    int month = project.ext.now.getMonthValue();
    int day = project.ext.now.getDayOfMonth();

    def version = "$year.$month.$day" as String

    updateConfig {
      it.year = year
      it.version = version
    }

    println "New version is $version"
  }

  void cleanFolderKeepMetadata() {
    if (parentDir.exists()) {
      project.delete {
        parentDir.eachFile { file ->
          if (file.isDirectory()) {
            project.delete(file)
          } else if (file.name in ['.metadata']) {
            // preserve metadata folder
          } else {
            file.delete()
          }
        }
      }
    }

    parentDir.mkdirs()
  }

  String getVersion() {
    def version = withConfig {
      it.version
    }
    if (!version) {
      // default to year snapshot
      int year = project.ext.now.getYear();
      "${year}-SNAPSHOT"
    }
    else {
      version
    }
  }

  String getSnapshot() {
    def version = withConfig {
      it.year
    }
    if (!version) {
      // default to current year
      int year = project.ext.now.getYear();
      "${year}-SNAPSHOT"
    }
    else {
      "${version}-SNAPSHOT"
    }
  }

  void generateJar(File sourceFolder, File targetFolder, String name) {
    def version = getVersion()

    // assemble different publication versions
    def fileVersions = new HashSet<>()
    fileVersions << version
    fileVersions << getSnapshot()
    fileVersions << 'CURRENT-SNAPSHOT'

    fileVersions.each { fileVersion ->

      def jarFile = new File(targetFolder, "${name}_${fileVersion}.jar")

      // OSGi symbolic name
      def symbolicName = "to.wetransform.offline-resources.${name}"

      //TODO include OSGi/hale related stuff?

      // build jar
      project.ant.jar(destfile: jarFile) {
        fileset(dir: sourceFolder, includes: '**/*')
        manifest {
          attribute(name: 'Implementation-Version', value: version)
          // OSGi related metadata
          attribute(name: 'Bundle-Version', value: fileVersion)
          attribute(name: 'Bundle-Name', value: "Offline Resource bundle ${name}")
          attribute(name: 'Bundle-ManifestVersion', value: 2)
          attribute(name: 'Bundle-SymbolicName', value: "$symbolicName;singleton:=true")
        }
      }

    }
  }
}

class ResourcesArchiveTask extends DefaultTask {
  // the host that the resource bundle mirrors resources from
  def host
  // the remote URL to retrieve the resource ZIP archive from
  def archiveUrl

  @TaskAction
  def downloadAndExtract() {
    assert host
    assert archiveUrl

    // download archive
    File tmpSchemas = new File(temporaryDir, 'schemas.zip')
    project.download {
      src archiveUrl
      dest tmpSchemas
      onlyIfModified true
    }

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    project.copy {
      // exclude Zip files
      exclude('**/*.zip')

      from project.zipTree(tmpSchemas)
      into targetDir
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class WgetHostIndexDownloadTask extends DefaultTask {
  // the list of URLs pointing to a web server index
  List<String> indexUrls
  // the list of extensions to accept
  List<String> fileExtensions

  @TaskAction
  def download() {
    assert indexUrls

    def hosts = indexUrls.collect { URI.create(it).host }.unique()
    assert hosts.size() == 1 : 'Index URLs must be from same host'

    def host = hosts[0]

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    for (String indexUrl : indexUrls) {
      // download files
      project.exec {
        workingDir = targetDir
        executable = 'wget' // requires wget
        def runArgs = ['-e', 'robots=off', '-r', '--no-parent', '--no-host-directories']
        if (fileExtensions) {
          runArgs << '-A'
          runArgs << fileExtensions.join(',')
        }
        runArgs << indexUrl
        args = runArgs
      }
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class HostPathsDownloadTask extends DefaultTask {
  // the host that the resource bundle mirrors resources from
  def hostUrl
  // the paths of the files that should be retrieved from the host
  List<String> paths

  @TaskAction
  def downloadPaths() {
    assert hostUrl
    assert paths

    // determine host
    def host = URI.create(hostUrl).host
    assert host

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    for (String path : paths) {
      File localFile = new File(targetDir, path)
      def fileUrl = hostUrl + "/" + path

      // download file
      project.download {
        src fileUrl
        dest localFile
        overwrite true
      }
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class WgetHostPathsDownloadTask extends DefaultTask {
  // the host that the resource bundle mirrors resources from
  def hostUrl
  // the paths of the files that should be retrieved from the host
  List<String> paths

  @TaskAction
  def downloadPaths() {
    assert hostUrl
    assert paths

    // determine host
    def host = URI.create(hostUrl).host
    assert host

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    for (String path : paths) {
      def fileUrl = hostUrl + "/" + path

      // download file
      project.exec {
        workingDir = targetDir
        executable = 'wget' // requires wget
        args '--force-directories', '--no-host-directories', fileUrl
      }
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class XmlSchemaDownloadTask extends DefaultTask {
  // the location of the remote schema
  def schemaUrl
  // the name if the schema
  def schemaName
  // the name of the resource group
  def resourceGroup

  @TaskAction
  def download() {
    assert schemaUrl
    assert schemaName
    assert resourceGroup

    File schemaTargetDir = project.file("${project.ext.resourcesFolder}/$resourceGroup/$schemaName")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, schemaTargetDir)
    md.cleanFolderKeepMetadata()

    File schemaFile = new File(schemaTargetDir, 'schema.xsd')

    // download archive
    project.download {
      src schemaUrl
      dest schemaFile
      overwrite true
    }

    // update schema file and download references
    eu.esdihumboldt.hale.common.core.io.project.util.XMLSchemaUpdater.update(
      schemaFile, URI.create(schemaUrl), true, null)

    // update version on change
    md.setVersionIfChanged()
    md.withConfig {
      it.originalLocation = schemaUrl as String
    }
  }
}


/**
 * Dummy task for testing (changes result on every run)
 */
task('dummy') {
  group 'Download'
  description 'Dummy download task for testing'
}.doFirst {
  def host = 'example.com'
  File targetDir = project.file("${project.ext.hostsFolder}/$host")

  // clean up before download to remove any obsolete files
  def md = new MetadataHelper(project, targetDir)
  md.cleanFolderKeepMetadata()

  def content = now.toString()

  new File(targetDir, 'root.txt').text = content
  def subfolder = new File(targetDir, 'sub')
  subfolder.mkdirs()
  new File(subfolder, 'sub.txt').text = content

  // update version on change
  md.setVersionIfChanged()
}

/*
 * Download tasks
 */

/**
 * Aggregation task for downloads
 */
task('downloads') {
  group 'Download'
  description 'Runs all downloads'
}

/**
 * Schemas from schemas.opengis.net
 */
task opengisSchemas(type: ResourcesArchiveTask) {
  group 'Download'
  host = "schemas.opengis.net"
  archiveUrl = "http://schemas.opengis.net/SCHEMAS_OPENGIS_NET.zip"
}
tasks.downloads.dependsOn(opengisSchemas)

/**
 * Schemas from www.w3.org
 */
task w3Schemas(type: HostPathsDownloadTask) {
  group 'Download'
  hostUrl = "https://www.w3.org"
  paths = [
    '1999/xlink.xsd',
    '2001/xml.xsd',
    '2001/XMLSchema.xsd',
    '2005/08/addressing/ws-addr.xsd'
  ]
}
tasks.downloads.dependsOn(w3Schemas)

/**
 * Schemas from schemas.geosciml.org
 */
task geoscimlSchemas(type: HostPathsDownloadTask) {
  // this schema seems to used in deegree in some context
  // most other schemas related to GeoSciML seem to be available via OGC
  group 'Download'
  hostUrl = "http://schemas.geosciml.org"
  paths = [
    'cgiutilities/3.0/cgiUtilities.xsd'
  ]
}
tasks.downloads.dependsOn(geoscimlSchemas)

/**
 * Schemas from portele.de
 */
task porteleSchemas(type: HostPathsDownloadTask) {
  group 'Download'
  hostUrl = "http://portele.de"
  paths = [
    'ShapeChangeAppinfo.xsd'
  ]
}
tasks.downloads.dependsOn(porteleSchemas)

/**
 * INSPIRE schemas
 */
/* FIXME download of INSPIRE schemas is currently broken because of changes to how the schemas are served
task inspireSchemas(type: WgetHostIndexDownloadTask) {
  group 'Download'
  indexUrls = [
    'https://inspire.ec.europa.eu/schemas/',
    'https://inspire.ec.europa.eu/draft-schemas/'
  ]
  fileExtensions = [
    'xsd',
    'xml',
    'txt'
  ]
}
tasks.downloads.dependsOn(inspireSchemas)
*/

/**
 * Schemas for metadata validation:
 *
 * http://build-artifacts.wetransform.to/schemas/iso19139/2012-07-13/gmd/gmd.xsd (gmd version "2012-07-13")
 *     - mirrored version of the schema at https://standards.iso.org/iso/19139/Schemas/gmd/gmd.xsd
 *       with relativized schema references to the ISO 19139 and ISO 19136 (GML) XSDs
 * https://www.isotc211.org/2005/gmd/gmd.xsd (gmd version "0.1")
 * https://www.isotc211.org/2005/gmx/gmx.xsd
 * http://schemas.opengis.net/csw/2.0.2/profiles/apiso/1.0.0/apiso.xsd
 */

/* FIXME for now disabled because at least on of the resources is not longer accessible like that
   TODO recreate missing resources in file system and re-enable tasks that still work
task metadataIso(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'http://build-artifacts.wetransform.to/schemas/iso19139/2012-07-13/gmd/gmd.xsd'
  schemaName = 'ISO_19139_GMD'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataIso)

task metadataIsoTC211(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'https://www.isotc211.org/2005/gmd/gmd.xsd'
  schemaName = 'ISO_TC211_GMD'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataIsoTC211)

task metadataExtensionsIsoTC211(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'https://www.isotc211.org/2005/gmx/gmx.xsd'
  schemaName = 'ISO_TC211_GMX'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataExtensionsIsoTC211)

task metadataCSW2(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'http://schemas.opengis.net/csw/2.0.2/profiles/apiso/1.0.0/apiso.xsd'
  schemaName = 'CSW_2_APISO'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataCSW2)
*/


/*
 * Processing tasks
 */

/**
 * Task for creating resource JARs for use in Java applications
 */
task(jars) {

}.doLast {

  /*
   * JARs for host folders
   */
  def files = project.ext.hostsFolder.listFiles()
  project.logger.info("Identified ${files.size()} potential host JARs")

  jarFolder.deleteDir()
  jarFolder.mkdirs()

  def tmpJarFolder = new File(temporaryDir, 'jar')

  files.each { File file ->
    // for each host folder
    if (file.isDirectory()) {
      println "Creating resources JARs for host ${file.name}"

      // prepare structure for inside JAR
      // use sub-directories to avoid confusion w/ other resources
      tmpJarFolder.deleteDir()
      tmpJarFolder.mkdirs()

      def resFolder = new File(tmpJarFolder, "to/wetransform/offline-resources/hosts/${file.name}")
      resFolder.mkdirs()

      copy {
        from file
        into resFolder

        exclude "${MetadataHelper.METADATA_DIR_NAME}/**"
      }

      def md = new MetadataHelper(project, file)
      md.generateJar(tmpJarFolder, jarFolder, file.name)
    }
  }

  /*
   * JARs for other folders
   */
  files = project.ext.resourcesFolder.listFiles()

  files.each { File file ->
    if (file.isDirectory() && !file.name.equals('hosts')) {
      println "Creating resources JARs for ${file.name}"

      // prepare structure for inside JAR
      // use sub-directories to avoid confusion w/ other resources
      tmpJarFolder.deleteDir()
      tmpJarFolder.mkdirs()

      def resFolder = new File(tmpJarFolder, "to/wetransform/offline-resources/${file.name}")
      resFolder.mkdirs()

      copy {
        from file
        into resFolder

        exclude "${MetadataHelper.METADATA_DIR_NAME}/**"
      }

      def md = new MetadataHelper(project, file)
      md.generateJar(tmpJarFolder, jarFolder, file.name)
    }
  }

}

/**
 * Task that publishes all Jars to artifactory.
 */
task('publishJars', type: GradleBuild) {
  buildFile = file('publish.gradle')

  startParameter.projectProperties.publications = jarFolder.getAbsolutePath()

  tasks = ['publish']
}

/**
 * Task for creating resource bundles used by hale
 */
task haleResourceBundles() {
  //TODO separate task or adapt hale functionality to work with JARs built in jars task?
}
