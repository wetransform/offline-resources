import java.time.*
import java.time.format.*
import java.time.temporal.*
import eu.esdihumboldt.util.config.*

buildscript {
  repositories {
    // mavenLocal()
    maven {
      url 'https://artifactory.wetransform.to/artifactory/local'
    }
    mavenCentral()
  }
  dependencies {
    // for Config class
    classpath 'eu.esdihumboldt.hale:eu.esdihumboldt.util.config:4.0.0'
    // for XMLSchemaUpdater (depends on https://github.com/halestudio/hale/pull/731)
    classpath 'eu.esdihumboldt.hale:eu.esdihumboldt.hale.common.core:4.0.0'

    classpath 'org.ajoberstar.grgit:grgit-core:4.1.1'
  }
}

plugins {
  id 'de.undercouch.download' version '5.5.0'
}

ext {
  resourcesFolder = file('resources')
  hostsFolder = new File(resourcesFolder, 'hosts')
  jarFolder = new File(buildDir, 'jars')
  now = LocalDate.now()
  time = LocalTime.now().format(DateTimeFormatter.ofPattern('HHmmss'))
  grgit = org.ajoberstar.grgit.Grgit.open(dir: projectDir)
}

wrapper {
  gradleVersion = '8.4'
}

/*
 * Helper classes and task definitions
 */

class MetadataHelper {
  static final METADATA_DIR_NAME = '.metadata'

  private final Project project
  private final File parentDir
  private final File metadataDir
  MetadataHelper(Project project, File parentDir) {
    this.project = project
    this.parentDir = parentDir
    this.metadataDir = new File(parentDir, METADATA_DIR_NAME)
  }

  def withConfig(Closure configure) {
    def configFile = new File(metadataDir, 'metadata.yml')
    configFile.parentFile.mkdirs()
    def config = configFile.exists() ? ConfigYaml.load(configFile) : new Config()
    // unexpectedly, when accessing config, instead of getAt get is used
    // when accessing config -> thus we interact with the map instead
    def map = config.asMap()
    def result = configure(map)
    result
  }

  def updateConfig(Closure configure) {
    def configFile = new File(metadataDir, 'metadata.yml')
    configFile.parentFile.mkdirs()
    def config = configFile.exists() ? ConfigYaml.load(configFile) : new Config()
    // unexpectedly, when accessing config, instead of getAt get is used
    // when accessing config -> thus we interact with the map instead
    def map = config.asMap()
    def result = configure(map)
    ConfigYaml.save(config, configFile)
    result
  }

  private boolean changesInFolder() {
    File checkForDir = parentDir
    File repoRoot = project.projectDir

    def relativePath = repoRoot.relativePath(checkForDir)
    //XXX do we need to replace \ with / for Windows?

    // add changes on relative path to index, so something like line-ending changes is not registered
    project.ext.grgit.add(patterns: [relativePath])

    def status = project.ext.grgit.status()

    // check for any changes and conflicts
    return [
      status.conflicts,
      status.staged.added,
      status.staged.modified,
      status.staged.removed,
      status.unstaged.added,
      status.unstaged.modified,
      status.unstaged.removed
    ].any { setOfPaths ->
      def example = setOfPaths.find { it.startsWith(relativePath) && !it.startsWith(relativePath + '/.metadata') }
      if (example) {
        println "Changes detected for path $relativePath (at least $example changed)"
        true
      }
      else {
        false
      }
    }
  }

  void setVersionIfChanged() {
    // only set version if there are changes to parentDir
    if (!changesInFolder()) {
      return
    }

    int year = project.ext.now.getYear();
    int month = project.ext.now.getMonthValue();
    int day = project.ext.now.getDayOfMonth();

    def version = "$year.$month.$day" as String

    updateConfig {
      it.year = year
      if (it.version == version) {
        // same version -> add time as qualifier (OSGi style version)
        version = ("${version}.${project.ext.time}" as String)
        if (it.version == version) {
          // still the same -> fail
          throw new IllegalStateException('Change detected but same version is already set')
        }
      }
      it.version = version
    }

    println "New version is $version"
  }

  void cleanFolderKeepMetadata() {
    if (parentDir.exists()) {
      parentDir.eachFile { file ->
        if (file.isDirectory()) {
          if (!file.name in ['.metadata']) {
            project.delete(file)
          }
        } else {
          file.delete()
        }
      }
    }

    parentDir.mkdirs()
  }

  String getVersion() {
    def version = withConfig {
      it.version
    }
    if (!version) {
      // default to year snapshot
      int year = project.ext.now.getYear();
      "${year}-SNAPSHOT"
    }
    else {
      version
    }
  }

  String getSnapshot() {
    def version = withConfig {
      it.year
    }
    if (!version) {
      // default to current year
      int year = project.ext.now.getYear();
      "${year}-SNAPSHOT"
    }
    else {
      "${version}-SNAPSHOT"
    }
  }

  void generateJar(File sourceFolder, File targetFolder, String name) {
    def version = getVersion()

    // assemble different publication versions
    def fileVersions = new HashSet<>()
    fileVersions << version
    fileVersions << getSnapshot()
    fileVersions << 'CURRENT-SNAPSHOT'

    fileVersions.each { fileVersion ->

      def jarFile = new File(targetFolder, "${name}_${fileVersion}.jar")

      // OSGi symbolic name
      def symbolicName = "to.wetransform.offline-resources.${name}"

      //TODO include OSGi/hale related stuff?

      // build jar
      project.ant.jar(destfile: jarFile) {
        fileset(dir: sourceFolder, includes: '**/*')
        manifest {
          attribute(name: 'Implementation-Version', value: version)
          // OSGi related metadata
          attribute(name: 'Bundle-Version', value: fileVersion)
          attribute(name: 'Bundle-Name', value: "Offline Resource bundle ${name}")
          attribute(name: 'Bundle-ManifestVersion', value: 2)
          attribute(name: 'Bundle-SymbolicName', value: "$symbolicName;singleton:=true")
        }
      }

    }
  }
}

class ResourcesArchiveTask extends DefaultTask {
  // the host that the resource bundle mirrors resources from
  @Input
  def host
  // the remote URL to retrieve the resource ZIP archive from
  @Input
  def archiveUrl

  @TaskAction
  def downloadAndExtract() {
    assert host
    assert archiveUrl

    // download archive
    File tmpSchemas = new File(temporaryDir, 'schemas.zip')
    project.download.run {
      src archiveUrl
      dest tmpSchemas
      onlyIfModified true
    }

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    project.copy {
      // exclude Zip files
      exclude('**/*.zip')

      from project.zipTree(tmpSchemas)
      into targetDir
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class INSPIREDownloadTask extends DefaultTask {
 // the host that the resource bundle mirrors resources from
  @Input
  def host
  // the remote URL to retrieve the resource ZIP archive from
  @Input
  def archiveUrl
  
  @TaskAction
  def downloadAndExtract() {
    assert host
    assert archiveUrl

    // need a clean tmp dir
    temporaryDir.deleteDir()
    temporaryDir.mkdir()

    // download archive
    File tmpSchemas = new File(temporaryDir, 'schemas.zip')
    project.download.run {
      src archiveUrl
      dest tmpSchemas
      onlyIfModified true
    }
    File targetDir = project.file("${project.ext.hostsFolder}/$host")
    // delete folder
    targetDir.deleteDir()
    targetDir.mkdirs()

    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()
  
    project.copy {
      // Exclude Zip files, 'governance' folder, and 'readme.md' file
      exclude('**/*.zip', 'application-schemas-main/governance-release-process/**', 'application-schemas-main/README.md', 'application-schemas-main/.github/**')
  
    from project.zipTree(tmpSchemas)
    into temporaryDir
    }

    /*
     * The website does redirect for some schemas to a subfolder with older versions.
     * For example `hy-p/3.0/HydroPhysicalWaters.xsd` is redirected to `2021.1/hy-p/3.0/HydroPhysicalWaters.xsd`
     * The resource bundles don't know about these redirects, the file from the original folder is accessed.
     * Loading the full schema may fail though, because some schema have been removed from the root and are only
     * available in folders representing older versions.
     * Examples:
     * - `lc/0.0/LandCover.xsd`
     * - `wfd/0.0/WaterFrameworkDirective.xsd`
     *
     * Since we don't know the exact redirection rules we attempt to have a copy of al schemas in the root, in
     * their respective newest version, by copying newer versions over older versions.
     */

    File applicationtempschemas = new File(temporaryDir, 'application-schemas-main')
    File tempRoot = new File(applicationtempschemas, 'tmp-schemas')
    def versions = ['2021.1', '2021.2', '2022.1', '2022.2']
    // copy all versions in order
    versions.each { v ->
      project.copy {
        from new File(applicationtempschemas, "schemas/$v")
        into tempRoot
        include '**/*'
      }
    }

    project.copy {
      from new File(applicationtempschemas, "schemas")
      into tempRoot
      include '**/*'
    }

    File applicationTempSchemasfolder = new File(applicationtempschemas, 'schemas')
    applicationTempSchemasfolder.deleteDir()
    File applicationTempSchemasfolderNew = new File(applicationtempschemas, 'schemas')
    tempRoot.renameTo(applicationTempSchemasfolderNew)

    // List all files in the subfolder
    def files = applicationtempschemas.listFiles()

    // Copy each file to the parent folder
    files.each { file ->
      def destination = new File(targetDir, file.name)
      file.renameTo(destination)
    }

    // update version on change
    md.setVersionIfChanged()
  }
  }

class WgetHostIndexDownloadTask extends DefaultTask {
  // the list of URLs pointing to a web server index
  @Input
  List<String> indexUrls
  // the list of extensions to accept
  @Input
  List<String> fileExtensions

  @TaskAction
  def download() {
    assert indexUrls

    def hosts = indexUrls.collect { URI.create(it).host }.unique()
    assert hosts.size() == 1 : 'Index URLs must be from same host'

    def host = hosts[0]

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    for (String indexUrl : indexUrls) {
      // download files
      project.exec {
        workingDir = targetDir
        executable = 'wget' // requires wget
        def runArgs = ['-e', 'robots=off', '-r', '--no-parent', '--no-host-directories']
        if (fileExtensions) {
          runArgs << '-A'
          runArgs << fileExtensions.join(',')
        }
        runArgs << indexUrl
        args = runArgs
      }
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class HostPathsDownloadTask extends DefaultTask {
  // the host that the resource bundle mirrors resources from
  @Input
  def hostUrl
  // the paths of the files that should be retrieved from the host
  @Input
  List<String> paths

  @TaskAction
  def downloadPaths() {
    assert hostUrl
    assert paths

    // determine host
    def host = URI.create(hostUrl).host
    assert host

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    for (String path : paths) {
      File localFile = new File(targetDir, path)
      def fileUrl = hostUrl + "/" + path

      // download file
      project.download.run {
        src fileUrl
        dest localFile
        overwrite true
      }
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class WgetHostPathsDownloadTask extends DefaultTask {
  // the host that the resource bundle mirrors resources from
  @Input
  def hostUrl
  // the paths of the files that should be retrieved from the host
  @Input
  List<String> paths

  @TaskAction
  def downloadPaths() {
    assert hostUrl
    assert paths

    // determine host
    def host = URI.create(hostUrl).host
    assert host

    File targetDir = project.file("${project.ext.hostsFolder}/$host")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, targetDir)
    md.cleanFolderKeepMetadata()

    for (String path : paths) {
      def fileUrl = hostUrl + "/" + path

      // download file
      project.exec {
        workingDir = targetDir
        executable = 'wget' // requires wget
        args '--force-directories', '--no-host-directories', fileUrl
      }
    }

    // update version on change
    md.setVersionIfChanged()
  }
}

class XmlSchemaDownloadTask extends DefaultTask {
  // the location of the remote schema
  @Input
  def schemaUrl
  // the name if the schema
  @Input
  def schemaName
  // the name of the resource group
  @Input
  def resourceGroup

  @TaskAction
  def download() {
    assert schemaUrl
    assert schemaName
    assert resourceGroup

    File schemaTargetDir = project.file("${project.ext.resourcesFolder}/$resourceGroup/$schemaName")

    // clean up before download to remove any obsolete files
    def md = new MetadataHelper(project, schemaTargetDir)
    md.cleanFolderKeepMetadata()

    File schemaFile = new File(schemaTargetDir, 'schema.xsd')

    // download archive
    project.download.run {
      src schemaUrl
      dest schemaFile
      overwrite true
    }

    // update schema file and download references
    eu.esdihumboldt.hale.common.core.io.project.util.XMLSchemaUpdater.update(
      schemaFile, URI.create(schemaUrl), true, null)

    // update version on change
    md.setVersionIfChanged()
    md.withConfig {
      it.originalLocation = schemaUrl as String
    }
  }
}


/**
 * Dummy task for testing (changes result on every run)
 */
task('dummy') {
  group 'Download'
  description 'Dummy download task for testing'
}.doFirst {
  def host = 'example.com'
  File targetDir = project.file("${project.ext.hostsFolder}/$host")

  // clean up before download to remove any obsolete files
  def md = new MetadataHelper(project, targetDir)
  md.cleanFolderKeepMetadata()

  def content = now.toString()

  new File(targetDir, 'root.txt').text = content
  def subfolder = new File(targetDir, 'sub')
  subfolder.mkdirs()
  new File(subfolder, 'sub.txt').text = content

  // update version on change
  md.setVersionIfChanged()
}

/*
 * Download tasks
 */

/**
 * Aggregation task for downloads
 */
task('downloads') {
  group 'Download'
  description 'Runs all downloads'
}

/**
 * Schemas from schemas.opengis.net
 */
task opengisSchemas(type: ResourcesArchiveTask) {
  group 'Download'
  host = "schemas.opengis.net"
  archiveUrl = "http://schemas.opengis.net/SCHEMAS_OPENGIS_NET.zip"
}
tasks.downloads.dependsOn(opengisSchemas)

/**
 * Schemas from www.w3.org
 */
task w3Schemas(type: HostPathsDownloadTask) {
  group 'Download'
  hostUrl = "https://www.w3.org"
  paths = [
    '1999/xlink.xsd',
    '2001/xml.xsd',
    '2001/XMLSchema.xsd',
    '2005/08/addressing/ws-addr.xsd'
  ]
}
tasks.downloads.dependsOn(w3Schemas)

/**
 * Schemas from schemas.geosciml.org
 */
task geoscimlSchemas(type: HostPathsDownloadTask) {
  // this schema seems to used in deegree in some context
  // most other schemas related to GeoSciML seem to be available via OGC
  group 'Download'
  hostUrl = "http://schemas.geosciml.org"
  paths = [
    'cgiutilities/3.0/cgiUtilities.xsd'
  ]
}
tasks.downloads.dependsOn(geoscimlSchemas)

/**
 * Schemas from portele.de
 */
task porteleSchemas(type: HostPathsDownloadTask) {
  group 'Download'
  hostUrl = "http://portele.de"
  paths = [
    'ShapeChangeAppinfo.xsd'
  ]
}
tasks.downloads.dependsOn(porteleSchemas)

/**
 * INSPIRE schemas
 */
task inspireSchemas(type: INSPIREDownloadTask) {
  group 'Download'
  host = "inspire.ec.europa.eu"
  archiveUrl = "https://github.com/INSPIRE-MIF/application-schemas/archive/refs/heads/main.zip"
}
tasks.downloads.dependsOn(inspireSchemas)


/**
 * Schemas for metadata validation:
 *
 * http://build-artifacts.wetransform.to/schemas/iso19139/2012-07-13/gmd/gmd.xsd (gmd version "2012-07-13")
 *     - mirrored version of the schema at https://standards.iso.org/iso/19139/Schemas/gmd/gmd.xsd
 *       with relativized schema references to the ISO 19139 and ISO 19136 (GML) XSDs
 * https://www.isotc211.org/2005/gmd/gmd.xsd (gmd version "0.1")
 * https://www.isotc211.org/2005/gmx/gmx.xsd
 * http://schemas.opengis.net/csw/2.0.2/profiles/apiso/1.0.0/apiso.xsd
 */

/* FIXME for now disabled because at least on of the resources is not longer accessible like that
   TODO recreate missing resources in file system and re-enable tasks that still work
task metadataIso(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'http://build-artifacts.wetransform.to/schemas/iso19139/2012-07-13/gmd/gmd.xsd'
  schemaName = 'ISO_19139_GMD'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataIso)

task metadataIsoTC211(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'https://www.isotc211.org/2005/gmd/gmd.xsd'
  schemaName = 'ISO_TC211_GMD'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataIsoTC211)

task metadataExtensionsIsoTC211(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'https://www.isotc211.org/2005/gmx/gmx.xsd'
  schemaName = 'ISO_TC211_GMX'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataExtensionsIsoTC211)

task metadataCSW2(type: XmlSchemaDownloadTask) {
  group 'Download'
  schemaUrl = 'http://schemas.opengis.net/csw/2.0.2/profiles/apiso/1.0.0/apiso.xsd'
  schemaName = 'CSW_2_APISO'
  resourceGroup = 'metadata-schemas'
}
tasks.downloads.dependsOn(metadataCSW2)
*/


/*
 * Processing tasks
 */

/**
 * Task for creating resource JARs for use in Java applications
 */
task(jars) {

}.doLast {

  /*
   * JARs for host folders
   */
  def files = project.ext.hostsFolder.listFiles()
  project.logger.info("Identified ${files.size()} potential host JARs")

  jarFolder.deleteDir()
  jarFolder.mkdirs()

  def tmpJarFolder = new File(temporaryDir, 'jar')

  files.each { File file ->
    // for each host folder
    if (file.isDirectory()) {
      println "Creating resources JARs for host ${file.name}"

      // prepare structure for inside JAR
      // use sub-directories to avoid confusion w/ other resources
      tmpJarFolder.deleteDir()
      tmpJarFolder.mkdirs()

      def resFolder = new File(tmpJarFolder, "to/wetransform/offline-resources/hosts/${file.name}")
      resFolder.mkdirs()

      copy {
        from file
        into resFolder

        exclude "${MetadataHelper.METADATA_DIR_NAME}/**"
      }

      def md = new MetadataHelper(project, file)
      md.generateJar(tmpJarFolder, jarFolder, file.name)
    }
  }

  /*
   * JARs for other folders
   */
  files = project.ext.resourcesFolder.listFiles()

  files.each { File file ->
    if (file.isDirectory() && !file.name.equals('hosts')) {
      println "Creating resources JARs for ${file.name}"

      // prepare structure for inside JAR
      // use sub-directories to avoid confusion w/ other resources
      tmpJarFolder.deleteDir()
      tmpJarFolder.mkdirs()

      def resFolder = new File(tmpJarFolder, "to/wetransform/offline-resources/${file.name}")
      resFolder.mkdirs()

      copy {
        from file
        into resFolder

        exclude "${MetadataHelper.METADATA_DIR_NAME}/**"
      }

      def md = new MetadataHelper(project, file)
      md.generateJar(tmpJarFolder, jarFolder, file.name)
    }
  }

}

/**
 * Task that publishes all Jars to artifactory.
 */
task('publishJars', type: GradleBuild) {
  buildFile = file('publish.gradle')
  buildName = 'publishJars'

  startParameter.projectProperties.publications = jarFolder.getAbsolutePath()

  tasks = ['publish']
}

/**
 * Task that publishes all Jars to the local maven repository.
 */
task('publishJarsToMavenLocal', type: GradleBuild) {
  buildFile = file('publish.gradle')
  buildName = 'publishJarsToMavenLocal'

  startParameter.projectProperties.publications = jarFolder.getAbsolutePath()

  tasks = ['publishToMavenLocal']
}

/**
 * Task that publishes current versions to an update site.
 * Requires Jars to be created and artifacts published to Maven Local beforehand.
 */
task('updateSite', type: GradleBuild) {
  buildFile = file('updatesite/build.gradle')
  buildName = 'updateSite'

  startParameter.projectProperties.publications = jarFolder.getAbsolutePath()

  tasks = ['clean', 'updateSite']
}

/**
 * Task for creating resource bundles used by hale
 */
task haleResourceBundles() {
  //TODO separate task or adapt hale functionality to work with JARs built in jars task?
}